<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>NexusCanon — Morphology Engine</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;

      --ink: rgba(255,255,255,.92);
      --mut: rgba(255,255,255,.62);
      --hair: rgba(255,255,255,.18);
      --hair2: rgba(255,255,255,.10);

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --ser: ui-serif, "Iowan Old Style","Palatino","Georgia",serif;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;

      --pad: clamp(16px, 3.8vw, 46px);
      --max: 1160px;
      --ease: cubic-bezier(.22,1,.36,1);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family:var(--sans);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      text-rendering:geometricPrecision;
      overflow-x:hidden;
    }

    /* Clean, disciplined grid — whisper only (not noise) */
    .field{
      position:fixed; inset:0; pointer-events:none; z-index:0;
    }
    .field .grid{
      position:absolute; inset:0;
      background-image:
        linear-gradient(rgba(255,255,255,.08) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,.08) 1px, transparent 1px);
      background-size: 36px 36px;
      opacity:.11;
      mix-blend-mode: screen;
    }
    .field .vignette{
      position:absolute; inset:0;
      background:
        radial-gradient(1200px 780px at 50% 45%, transparent 40%, rgba(0,0,0,.86) 78%);
    }

    /* Morphology engine layer */
    .morph{
      position:fixed; inset:0; z-index:1; pointer-events:none;
      opacity:.96;
      mix-blend-mode: screen; /* light behaves like light */
      filter: contrast(1.12) brightness(1.03);
    }
    .morph svg{ width:100%; height:100%; display:block; }

    /* Content */
    .wrap{ position:relative; z-index:2; }

    header{
      position:fixed; left:0; right:0; top:0; z-index:3;
      padding: 18px var(--pad);
      background: linear-gradient(to bottom, rgba(0,0,0,.70), rgba(0,0,0,0));
      backdrop-filter: blur(10px);
    }
    .nav{
      max-width: var(--max);
      margin:0 auto;
      display:flex; align-items:center; justify-content:space-between;
      gap:14px;
    }
    .brand{
      display:flex; align-items:center; gap:12px;
      font-family:var(--mono);
      letter-spacing:.34em;
      text-transform:uppercase;
      font-size:10px;
      color: rgba(255,255,255,.70);
      user-select:none;
    }
    .dot{
      width:10px; height:10px; border:1px solid rgba(255,255,255,.60);
      border-radius:999px; position:relative;
    }
    .dot:after{
      content:""; position:absolute; inset:2px;
      border:1px solid rgba(255,255,255,.22); border-radius:999px;
    }
    nav a{
      pointer-events:auto;
      font-family:var(--mono);
      font-size:10px;
      letter-spacing:.34em;
      text-transform:uppercase;
      color: rgba(255,255,255,.55);
      text-decoration:none;
      padding:10px 10px;
      border:1px solid transparent;
    }
    nav a:hover{
      color: rgba(255,255,255,.88);
      border-color: rgba(255,255,255,.18);
    }

    .section{
      min-height:100vh;
      display:flex;
      align-items:center;
      padding: calc(var(--pad)*2.3) var(--pad);
    }
    .inner{ width:100%; max-width:var(--max); margin:0 auto; }

    .micro{
      font-family:var(--mono);
      letter-spacing:.44em;
      text-transform:uppercase;
      font-size:10px;
      color:rgba(255,255,255,.42);
    }
    .rule{
      height:1px;
      background:linear-gradient(to right, transparent, rgba(255,255,255,.28), transparent);
      margin: 18px 0 22px;
    }

    /* Typography weapon: contrast by weight + spacing + rhythm */
    .wordmark{
      margin:0;
      font-family:var(--sans);
      font-weight:900;
      letter-spacing:-.065em;
      line-height:.90;
      font-size: clamp(62px, 9.4vw, 132px);
      color:#fff;
      text-transform:uppercase;
      display:inline-block;
      position:relative;
    }
    /* Canon incision */
    .wordmark:after{
      content:"";
      position:absolute;
      left:-6%;
      right:-10%;
      top: 56%;
      height:1px;
      background: linear-gradient(to right, transparent, rgba(255,255,255,.68), transparent);
      opacity:.58;
      transform: rotate(-0.35deg);
    }

    .submark{
      margin-top:10px;
      font-family:var(--mono);
      letter-spacing:.52em;
      text-transform:uppercase;
      font-size:10px;
      color: rgba(255,255,255,.40);
    }

    .lead{
      margin: 18px 0 0;
      font-family:var(--ser);
      font-size: clamp(15px, 1.55vw, 18px);
      line-height: 1.76;
      color: rgba(255,255,255,.62);
      max-width: 76ch;
    }

    .h2{
      margin:0;
      font-family:var(--sans);
      font-weight:900;
      letter-spacing:-.055em;
      text-transform:uppercase;
      font-size: clamp(34px, 4.9vw, 64px);
      line-height:.94;
    }
    .aside{
      margin-top:14px;
      font-family:var(--ser);
      color: rgba(255,255,255,.58);
      line-height:1.85;
      max-width:74ch;
      font-size: 15px;
    }

    .plates{
      margin-top:30px;
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
    }
    @media (max-width: 920px){
      .plates{ grid-template-columns: 1fr; }
    }

    /* Minimal plates (not “SaaS cards”) */
    .plate{
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.28);
      backdrop-filter: blur(10px);
      padding:20px;
      position:relative;
      overflow:hidden;
    }
    .plate:before{
      content:""; position:absolute; inset:10px;
      border:1px solid rgba(255,255,255,.10);
      pointer-events:none;
    }

    .white{
      background:#fff; color:#000;
      border:2px solid #fff;
    }
    .white .micro{ color: rgba(0,0,0,.55); }
    .white .rule{
      background:linear-gradient(to right, transparent, rgba(0,0,0,.34), transparent);
    }

    footer{
      padding: 70px var(--pad);
    }
    .foot{
      max-width:var(--max); margin:0 auto;
      display:flex; flex-wrap:wrap; gap:18px; align-items:flex-end; justify-content:space-between;
      border-top:1px solid rgba(255,255,255,.14);
      padding-top:28px;
    }
    .foot .left{
      font-family:var(--ser);
      font-size:22px;
      color: rgba(255,255,255,.90);
      letter-spacing:-.02em;
      line-height:1.15;
    }
    .foot .right{
      font-family:var(--mono);
      font-size:10px;
      letter-spacing:.42em;
      text-transform:uppercase;
      color: rgba(255,255,255,.42);
    }

    .whisper{
      position:fixed; right:18px; top:50%; transform: translateY(-50%);
      font-family:var(--mono); font-size:10px; letter-spacing:.42em;
      color: rgba(255,255,255,.16);
      writing-mode: vertical-rl;
      z-index:3;
      user-select:none;
      pointer-events:none;
    }
  </style>
</head>

<body>
  <header>
    <div class="nav">
      <div class="brand"><span class="dot"></span><span>NexusCanon</span></div>
      <nav>
        <a href="#truth">Truth</a>
        <a href="#discipline">Discipline</a>
        <a href="#morph">Morphology</a>
        <a href="#dna">DNA</a>
      </nav>
    </div>
  </header>

  <div class="field" aria-hidden="true">
    <div class="grid"></div>
    <div class="vignette"></div>
  </div>

  <!-- MORPHOLOGY ENGINE (single system evolves) -->
  <div class="morph" aria-hidden="true">
    <svg id="morphSvg" viewBox="0 0 1000 700" preserveAspectRatio="none">
      <defs>
        <!-- Soft bloom for “luxury tension” (not noise) -->
        <filter id="nxBloom" x="-30%" y="-30%" width="160%" height="160%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="1.2" result="b1"/>
          <feGaussianBlur in="SourceGraphic" stdDeviation="4.0" result="b2"/>
          <feColorMatrix in="b2" type="matrix"
            values="
              1 0 0 0 0
              0 1 0 0 0
              0 0 1 0 0
              0 0 0 .16 0" result="b2a"/>
          <feMerge>
            <feMergeNode in="b1"/>
            <feMergeNode in="b2a"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>

        <!-- Scan highlight band -->
        <linearGradient id="nxScanGrad" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0" stop-color="rgba(255,255,255,0)"/>
          <stop offset=".48" stop-color="rgba(255,255,255,.16)"/>
          <stop offset=".52" stop-color="rgba(255,255,255,0)"/>
          <stop offset="1" stop-color="rgba(255,255,255,0)"/>
        </linearGradient>
      </defs>

      <g id="morphGroup" filter="url(#nxBloom)"></g>
      <rect id="nxScan" x="-40" y="-220" width="1080" height="240"
            fill="url(#nxScanGrad)" opacity="0.62" style="mix-blend-mode:screen"></rect>
    </svg>
  </div>

  <div class="whisper" aria-hidden="true">LINE→THREAD→BOX→CARD→CURVE</div>

  <main class="wrap">
    <!-- HERO -->
    <section class="section" id="truth">
      <div class="inner">
        <div class="micro">forensic accounting erp</div>
        <div class="rule"></div>

        <div class="wordmark">NEXUS<br/>CANON</div>
        <div class="submark">engine of truth · ssot · evidence</div>

        <p class="lead">
          NexusCanon is not a “dashboard”. It is a ledger system designed to be explainable:
          every figure carries lineage, every action leaves evidence, and drift is structurally refused.
        </p>

        <div class="plates">
          <div class="plate">
            <div class="micro">accounting</div>
            <div class="rule"></div>
            <div class="h2" style="font-size:clamp(44px,5.7vw,78px)">1 + 1<br/>= 2</div>
            <div class="aside">
              Unchanging mathematics. Posting identity never breaks. Reversals remain truth.
            </div>
          </div>

          <div class="plate white">
            <div class="micro">forensic</div>
            <div class="rule"></div>
            <div class="h2" style="color:#000; font-size:clamp(28px,3.2vw,44px); letter-spacing:-.03em;">
              THE<br/>PSYCHOLOGY<br/>OF NUMBERS
            </div>
            <div style="margin-top:12px; font-family:var(--ser); color:rgba(0,0,0,.70); line-height:1.76;">
              Every transaction tells a story.<br/>Every pattern reveals intent.<br/>Every number is evidence.
            </div>
            <div style="margin-top:18px; height:56px; border:2px solid #000;"></div>
            <div style="margin-top:12px; font-family:var(--mono); letter-spacing:.26em; font-size:11px;">SSOT · LOCKED</div>
          </div>
        </div>
      </div>
    </section>

    <!-- DISCIPLINE -->
    <section class="section" id="discipline">
      <div class="inner">
        <div class="micro">equilibrium</div>
        <div class="rule"></div>
        <div class="h2">Accounting<br/>is the discipline.</div>
        <div class="aside">
          Forensic is not decoration. It is what happens when discipline meets intent.
          Extreme black weight + extreme white space = luxury through tension, not through more elements.
        </div>
      </div>
    </section>

    <!-- MORPH -->
    <section class="section" id="morph">
      <div class="inner">
        <div class="micro">morphology engine</div>
        <div class="rule"></div>
        <div class="h2">Evidence evolves.</div>
        <div class="aside">
          Real morphology means the same system transforms:
          lines become threads, threads become boxes, boxes become cards, cards become curves —
          and the equilibrium holds the violence as elegance.
        </div>
      </div>
    </section>

    <!-- DNA -->
    <section class="section" id="dna">
      <div class="inner">
        <div class="micro">nexuscanon dna</div>
        <div class="rule"></div>
        <div class="h2">Precision · Intelligence · Evolution</div>
        <div class="aside">
          Trust is built when the visuals behave like the system: minimal, strict, and quietly forensic.
        </div>
      </div>
    </section>

    <footer>
      <div class="foot">
        <div class="left">Trust is built<br/>one reconciliation at a time.</div>
        <div class="right">© 2025 NexusCanon · B/W DNA · SSOT</div>
      </div>
    </footer>
  </main>

  <script>
    /* =========================================================
      MORPHOLOGY ENGINE (REAL TRANSFORMATION, NO NOISE)
      - One family of primitives evolves with scroll.
      - LINE → THREAD → BOX → CARD → CURVE
      - Equilibrium: fewer elements, higher meaning.
    ========================================================= */

    const svg = document.getElementById("morphSvg");
    const g = document.getElementById("morphGroup");
    const scan = document.getElementById("nxScan");
    const reduced = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

    const S = { scroll01: 0 };

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function smoothstep(t){ t = clamp(t,0,1); return t*t*(3-2*t); }

    function el(name, attrs){
      const n = document.createElementNS("http://www.w3.org/2000/svg", name);
      for(const k in attrs){ if(attrs[k] != null) n.setAttribute(k, String(attrs[k])); }
      return n;
    }

    // Stage windows along scroll
    // 0..1 scroll => 5 morph states with overlap (no hard cuts)
    function stageT(s, a, b){
      // returns smooth 0..1 between [a..b]
      return smoothstep((s - a) / (b - a));
    }

    // A single ribbon centerline (disciplined curve)
    // We'll draw multiple parallel strokes (threads) and then spawn rectangles along it (boxes/cards).
    const curveA = { // calmer
      p0:[-80, 520], p1:[160, 470], p2:[320, 610], p3:[520, 515], p4:[640, 405], p5:[820, 460], p6:[1120, 560]
    };
    const curveB = { // tighter (more forensic pressure)
      p0:[-80, 520], p1:[170, 450], p2:[340, 640], p3:[540, 500], p4:[670, 380], p5:[860, 500], p6:[1120, 560]
    };

    function curvePath(mix){
      // Build a cubic-ish path using two cubics (simple but stable)
      const A = curveA, B = curveB;
      function mixPt(i){
        const a = A[i], b = B[i];
        return [lerp(a[0], b[0], mix), lerp(a[1], b[1], mix)];
      }
      const p0 = mixPt("p0"), p1 = mixPt("p1"), p2 = mixPt("p2"),
            p3 = mixPt("p3"), p4 = mixPt("p4"), p5 = mixPt("p5"), p6 = mixPt("p6");

      // Two segments for smooth discipline
      return `M ${p0[0]} ${p0[1]}
              C ${p1[0]} ${p1[1]}, ${p2[0]} ${p2[1]}, ${p3[0]} ${p3[1]}
              C ${p4[0]} ${p4[1]}, ${p5[0]} ${p5[1]}, ${p6[0]} ${p6[1]}`;
    }

    // Engine primitives
    const lines = [];   // threads
    const rects = [];   // boxes/cards
    const frames = [];  // rare framing lines (discipline)

    function build(){
      g.innerHTML = "";
      lines.length = 0; rects.length = 0; frames.length = 0;

      // THREADS: start as 1 line, become many
      for(let i=0;i<13;i++){
        const p = el("path",{
          d: curvePath(0),
          fill:"none",
          stroke:"rgba(255,255,255,0.00)",
          "stroke-width":"1",
          "stroke-linecap":"round",
          "stroke-linejoin":"round"
        });
        g.appendChild(p);
        lines.push({ node:p, lane:i, baseOpacity: 0.06 + i*0.020 });
      }

      // BOXES/CARDS: anchored rectangles that will “appear” from the threads
      // fewer, heavier, meaningful
      const anchors = [
        { x: 120, y: 145, w: 320, h: 210 },
        { x: 510, y: 160, w: 340, h: 260 },
        { x: 180, y: 410, w: 280, h: 190 },
        { x: 560, y: 430, w: 360, h: 220 },
      ];

      anchors.forEach((a, idx)=>{
        const r = el("rect",{
          x:a.x, y:a.y, width:a.w, height:a.h,
          rx:0, ry:0,
          fill:"rgba(255,255,255,0)",
          stroke:"rgba(255,255,255,0)",
          "stroke-width":"1"
        });
        g.appendChild(r);
        rects.push({ node:r, a, idx });
      });

      // FRAME LINES: minimal, rare, purpose
      const frame1 = el("rect",{ x:70, y:90, width:860, height:520, rx:0, ry:0, fill:"transparent", stroke:"rgba(255,255,255,0)", "stroke-width":"1" });
      const frame2 = el("rect",{ x:84, y:104, width:832, height:492, rx:0, ry:0, fill:"transparent", stroke:"rgba(255,255,255,0)", "stroke-width":"1" });
      g.appendChild(frame1); g.appendChild(frame2);
      frames.push(frame1, frame2);

      // Calibration ticks (discipline, not noise)
      const ticks = el("g",{});
      g.appendChild(ticks);
      for(let i=0;i<16;i++){
        const xx = 70 + i*56;
        const hh = (i%3===0) ? 18 : 10;
        ticks.appendChild(el("line",{
          x1:xx, x2:xx, y1:14, y2:14+hh,
          stroke:"rgba(255,255,255,0.00)",
          "stroke-width":"1"
        }));
      }
      ticks.__lines = Array.from(ticks.querySelectorAll("line"));
      g.__ticks = ticks;
    }

    function computeScroll01(){
      const doc = document.documentElement;
      const max = Math.max(1, doc.scrollHeight - doc.clientHeight);
      S.scroll01 = clamp(doc.scrollTop / max, 0, 1);
    }

    function update(t){
      const s = S.scroll01;

      // Stage weights (overlapping)
      const tLine   = 1 - stageT(s, 0.10, 0.25);          // fades out as others come in
      const tThread = stageT(s, 0.12, 0.42);              // threads appear
      const tBox    = stageT(s, 0.28, 0.60);              // boxes appear
      const tCard   = stageT(s, 0.50, 0.82);              // cards fill
      const tCurve  = stageT(s, 0.66, 0.96);              // corners round (curve)

      // Forensic pressure tightens the path slightly
      const pressure = clamp((s - 0.30) / 0.60, 0, 1);
      const pathMix = smoothstep(pressure);

      // Update ribbon paths
      const d = curvePath(pathMix);

      // LINE → THREAD
      // 1 line is “truth line” (lane=6); others fade in as thread density.
      lines.forEach((r)=>{
        r.node.setAttribute("d", d);

        const isTruthLine = (r.lane === 6);
        const laneOffset = (r.lane - 6);

        // Threads spread grows with tThread
        const spread = lerp(0.0, 3.9, tThread);
        const yOff = laneOffset * spread;

        // Gentle breathing only (no noise)
        const wob = reduced ? 0 : Math.sin((t*0.00035) + r.lane*0.24) * lerp(0.0, 1.0, pressure) * 0.55;

        // Opacity logic:
        // - Truth line strong early
        // - Threads gradually appear with discipline
        const base = isTruthLine ? 0.40 : r.baseOpacity;
        const op = isTruthLine
          ? lerp(0.52, 0.38, tThread) * (0.65 + 0.35*tLine)
          : base * tThread;

        r.node.setAttribute("stroke", `rgba(255,255,255,${op.toFixed(3)})`);
        r.node.setAttribute("transform", `translate(0 ${(yOff + wob).toFixed(2)})`);
      });

      // THREAD → BOX → CARD → CURVE
      rects.forEach((r)=>{
        const a = r.a;

        // stroke appears at box stage
        const strokeOp = lerp(0.0, 0.22, tBox);

        // fill appears at card stage (white mass = luxury tension)
        // but never full white everywhere — selective
        const fillOp = (r.idx === 1)
          ? lerp(0.0, 0.08, tCard)          // keep most cards subtle
          : lerp(0.0, 0.05, tCard);

        // curve (rounding) appears late
        const rad = lerp(0, 22, tCurve);

        // “equilibrium”: as cards fill, strokes get a hair thinner
        const sw = lerp(2, 1, tCard);

        r.node.setAttribute("rx", rad.toFixed(2));
        r.node.setAttribute("ry", rad.toFixed(2));
        r.node.setAttribute("stroke-width", sw.toFixed(2));
        r.node.setAttribute("stroke", `rgba(255,255,255,${strokeOp.toFixed(3)})`);
        r.node.setAttribute("fill", `rgba(255,255,255,${fillOp.toFixed(3)})`);
      });

      // Frames appear only when structure matters (late discipline)
      frames.forEach((fr, i)=>{
        const op = lerp(0.0, i===0 ? 0.16 : 0.10, stageT(s, 0.42, 0.80));
        fr.setAttribute("stroke", `rgba(255,255,255,${op.toFixed(3)})`);
        fr.setAttribute("rx", lerp(0, 18, tCurve).toFixed(2));
        fr.setAttribute("ry", lerp(0, 18, tCurve).toFixed(2));
      });

      // Ticks fade in (instrumentation)
      const ticks = g.__ticks;
      if(ticks && ticks.__lines){
        const op = lerp(0.0, 0.20, stageT(s, 0.22, 0.62));
        ticks.__lines.forEach(l => l.setAttribute("stroke", `rgba(255,255,255,${op.toFixed(3)})`));
      }

      // Scan band (subtle, not gimmick)
      if(!reduced){
        const y = -240 + ((t * 0.03 + s * 680) % 980);
        scan.setAttribute("transform", `translate(0 ${y.toFixed(2)})`);
        scan.style.opacity = String(lerp(0.0, 0.62, stageT(s, 0.18, 0.55)));
      } else {
        scan.style.opacity = "0";
      }

      requestAnimationFrame(update);
    }

    build();
    computeScroll01();
    window.addEventListener("scroll", computeScroll01, { passive:true });
    requestAnimationFrame(update);
  </script>
</body>
</html>
