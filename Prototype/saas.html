<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>NexusCanon — Morphology Engine (B&W)</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --hair:rgba(255,255,255,.18);
      --hair2:rgba(255,255,255,.10);
      --ink:rgba(255,255,255,.88);
      --mut:rgba(255,255,255,.55);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --ser: ui-serif, "Iowan Old Style","Palatino","Georgia",serif;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --ease:cubic-bezier(.22,1,.36,1);
      --pad:clamp(16px,3.6vw,44px);
      --max:1120px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family:var(--sans);
      text-rendering:geometricPrecision;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow-x:hidden;
    }

    /* Fixed HUD + Morph field */
    .hud{
      position:fixed; inset:0; pointer-events:none; z-index:0;
    }
    .hud .grid{
      position:absolute; inset:0;
      background-image:
        linear-gradient(rgba(255,255,255,.08) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,.08) 1px, transparent 1px);
      background-size: 34px 34px;
      opacity:.14;
      mix-blend-mode:screen;
    }
    .hud .v{
      position:absolute; inset:0;
      background: radial-gradient(1200px 700px at 50% 45%, transparent 35%, rgba(0,0,0,.84) 78%);
    }

    /* Morphology SVG layer */
    .morph{
      position:fixed; inset:0; z-index:1; pointer-events:none;
      opacity:.92;
      transform: translateZ(0);
    }
    .morph svg{ width:100%; height:100%; display:block; }

    /* Page content */
    .wrap{ position:relative; z-index:2; }
    .section{
      min-height:100vh;
      display:flex;
      align-items:center;
      padding: calc(var(--pad)*2.1) var(--pad);
    }
    .inner{ width:100%; max-width:var(--max); margin:0 auto; }
    .micro{
      font-family:var(--mono);
      letter-spacing:.42em;
      text-transform:uppercase;
      font-size:10px;
      color:rgba(255,255,255,.45);
    }
    .rule{
      height:1px;
      background:linear-gradient(to right, transparent, rgba(255,255,255,.28), transparent);
      margin:22px 0;
    }
    h1{
      margin:0;
      font-family:var(--ser);
      letter-spacing:-.06em;
      line-height:.88;
      font-size:clamp(56px, 8.7vw, 112px);
    }
    p{
      margin:16px 0 0;
      font-family:var(--ser);
      font-size:clamp(15px, 1.5vw, 17px);
      line-height:1.74;
      color:rgba(255,255,255,.62);
      max-width:70ch;
    }

    /* Little “evidence slab” to test contrast */
    .slab{
      margin-top:26px;
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:16px;
    }
    @media (max-width:900px){ .slab{ grid-template-columns:1fr; } }
    .plate{
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.28);
      backdrop-filter: blur(10px);
      padding:20px;
      position:relative;
    }
    .plate:before{
      content:""; position:absolute; inset:10px;
      border:1px solid rgba(255,255,255,.10);
      pointer-events:none;
    }
    .white{
      background:#fff; color:#000;
      border:2px solid #fff;
      padding:22px;
    }
    .white .micro{ color:rgba(0,0,0,.55); }
    .mono{ font-family:var(--mono); letter-spacing:.26em; font-size:11px; }
  </style>
</head>

<body>
  <div class="hud" aria-hidden="true">
    <div class="grid"></div>
    <div class="v"></div>
  </div>

  <!-- Morphology Engine Layer -->
  <div class="morph" aria-hidden="true">
    <svg id="morphSvg" viewBox="0 0 1000 700" preserveAspectRatio="none"></svg>
  </div>

  <div class="wrap">
    <section class="section">
      <div class="inner">
        <div class="micro">nexuscanon · morphology engine</div>
        <div class="rule"></div>
        <h1>Truth,<br/>as a ledger<br/>that refuses drift.</h1>
        <p>
          Scroll. The morphology field is alive: threads, frames, ghosts — all quiet,
          all B&W, all behaving like forensic instrumentation rather than “cards”.
        </p>

        <div class="slab">
          <div class="plate">
            <div class="micro">mechanism</div>
            <div class="rule"></div>
            <div class="mono" style="color:rgba(255,255,255,.84)">EVENT → EVIDENCE → LEDGER</div>
          </div>
          <div class="white">
            <div class="micro">seal</div>
            <div style="margin-top:16px; height:54px; border:2px solid #000"></div>
            <div class="mono" style="margin-top:14px;">SSOT · LOCKED</div>
          </div>
        </div>
      </div>
    </section>

    <section class="section">
      <div class="inner">
        <div class="micro">boring by law</div>
        <div class="rule"></div>
        <h1>1 + 1 = 2</h1>
        <p>
          Accounting is invariant. The morphology should never “celebrate” — only annotate,
          hint, and create pressure.
        </p>
      </div>
    </section>

    <section class="section">
      <div class="inner">
        <div class="micro">forensic wakes</div>
        <div class="rule"></div>
        <h1>Pattern<br/>reveals intent.</h1>
        <p>
          Here, morphology becomes more suspicious: more dashes, more interrupted frames,
          more drift. Still restrained.
        </p>
      </div>
    </section>

    <section class="section">
      <div class="inner">
        <div class="micro">end</div>
        <div class="rule"></div>
        <h1>NEXUSCANON</h1>
        <p>Black & White DNA. No excuses, no palettes, no vibes.</p>
      </div>
    </section>
  </div>

  <script>
    /* ---------------------------
      Morphology Engine (Seeded)
      - Generates: threads (paths), frames (rect), ticks (lines), ghosts (rect fill)
      - Scroll drives: parallax, opacity, dash phase, drift, “pressure”
    --------------------------- */

    // Seeded RNG (xorshift32)
    function makeRand(seed){
      let t = seed | 0;
      return function(){
        t ^= (t << 13); t ^= (t >> 17); t ^= (t << 5);
        const n = Math.abs(t) % 1000000;
        return n / 1000000;
      }
    }

    const svg = document.getElementById("morphSvg");
    const rnd = makeRand(88);

    const state = {
      w: 1000, h: 700,
      frames: [],
      ghosts: [],
      threads: [],
      ticks: [],
      dashers: [],
      // input
      scroll01: 0,
      pointerX: 0.5,
      pointerY: 0.5,
      reduced: window.matchMedia("(prefers-reduced-motion: reduce)").matches
    };

    function el(name, attrs){
      const n = document.createElementNS("http://www.w3.org/2000/svg", name);
      for(const k in attrs){
        if(attrs[k] == null) continue;
        n.setAttribute(k, String(attrs[k]));
      }
      return n;
    }

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    function build(){
      svg.innerHTML = "";

      // Threads (curves)
      for(let i=0;i<3;i++){
        const y = lerp(120, 590, i/2) + (rnd()*30 - 15);
        const amp = 80 + rnd()*120;
        const d = `M-60,${y}
          C200,${y-amp} 320,${y+amp} 520,${y}
          C700,${y-amp*0.8} 860,${y+amp*0.7} 1080,${y-6}`;
        const p = el("path", {
          d,
          fill:"none",
          stroke:`rgba(255,255,255,${i===1?0.22:0.16})`,
          "stroke-width": "1"
        });
        svg.appendChild(p);
        state.threads.push({ node:p, baseY:y, amp });
      }

      // Frames (thin rectangles)
      for(let i=0;i<14;i++){
        const x = rnd()*860;
        const y = rnd()*520;
        const w = 120 + rnd()*520;
        const h = 70 + rnd()*360;
        const rx = Math.floor(rnd()*20);
        const sw = (i%6===0) ? 2 : 1;
        const o = (i%3===0) ? 0.26 : 0.16;
        const r = el("rect",{
          x, y, width:w, height:h, rx, ry:rx,
          fill:"transparent",
          stroke:`rgba(255,255,255,${o})`,
          "stroke-width": sw
        });
        svg.appendChild(r);
        state.frames.push({ node:r, x,y,w,h,rx, sw, o, kind:"frame" });

        // Some dashed frames (suspicion)
        if(i%4===0){
          r.setAttribute("stroke-dasharray", "9 14");
          state.dashers.push(r);
        }

        // Ghost fills (rare, like “evidence extracted”)
        if(i%5===0){
          const g = el("rect",{
            x: x+6, y: y+6,
            width: Math.max(0,w-12), height: Math.max(0,h-12),
            rx: Math.max(0,rx-6), ry: Math.max(0,rx-6),
            fill:`rgba(255,255,255,0.06)`,
            stroke:"transparent"
          });
          svg.appendChild(g);
          state.ghosts.push({ node:g, x,y,w,h });
        }
      }

      // Calibration ticks (top + right)
      for(let i=0;i<16;i++){
        const xx = 70 + i*56;
        const hh = (i%3===0) ? 18 : 10;
        const t = el("line",{
          x1: xx, x2: xx,
          y1: 14, y2: 14+hh,
          stroke:"rgba(255,255,255,0.22)",
          "stroke-width":"1"
        });
        svg.appendChild(t);
        state.ticks.push({ node:t, axis:"top", i });
      }
      for(let i=0;i<12;i++){
        const yy = 90 + i*46;
        const ww = (i%3===0) ? 18 : 10;
        const t = el("line",{
          x1: 980-ww, x2: 980,
          y1: yy, y2: yy,
          stroke:"rgba(255,255,255,0.18)",
          "stroke-width":"1"
        });
        svg.appendChild(t);
        state.ticks.push({ node:t, axis:"right", i });
      }
    }

    function update(){
      const s = state.scroll01;                 // 0..1 across whole page
      const px = (state.pointerX - 0.5);        // -0.5..0.5
      const py = (state.pointerY - 0.5);

      // Pressure curve: stronger in mid & late scroll (forensic wake)
      const pressure = clamp((s - 0.35) / 0.55, 0, 1);
      const calm = 1 - pressure;

      // Global parallax transform (subtle)
      const driftX = px * lerp(10, 28, pressure);
      const driftY = py * lerp(8, 22, pressure);
      svg.style.transform = `translate(${driftX}px, ${driftY}px)`;

      // Threads: breathe slightly with scroll (never hype)
      state.threads.forEach((t, idx)=>{
        const wobble = state.reduced ? 0 : Math.sin((s*6 + idx*1.7) * Math.PI) * lerp(3, 10, pressure);
        t.node.style.opacity = String(lerp(0.55, 0.85, pressure));
        // We “nudge” via stroke-opacity only (keep paths stable)
        const so = idx===1 ? lerp(0.22, 0.28, pressure) : lerp(0.14, 0.20, pressure);
        t.node.setAttribute("stroke", `rgba(255,255,255,${so})`);
        t.node.setAttribute("stroke-width", "1");
        t.node.setAttribute("filter", wobble ? "url(#none)" : "");
      });

      // Frames: become more “suspicious” later (dashes + opacity)
      state.frames.forEach((f, i)=>{
        const local = (i % 7) / 7; // static variety
        const lift = (local - 0.5) * lerp(8, 22, pressure);
        const ox = px * lerp(4, 10, pressure) * (0.4 + local);
        const oy = py * lerp(3, 8, pressure) * (0.4 + (1-local));
        const op = lerp(f.o, Math.min(0.38, f.o + 0.16), pressure);

        f.node.style.opacity = String(op);
        f.node.setAttribute("transform", `translate(${ox}px, ${oy + lift}px)`);

        // late scroll: slightly heavier strokes for “pressure”
        const sw = (i%6===0) ? 2 : 1;
        const sw2 = lerp(sw, sw + (i%5===0 ? 0.6 : 0.35), pressure);
        f.node.setAttribute("stroke-width", String(sw2));
      });

      // Ghosts: appear a bit more as evidence “extracted”
      state.ghosts.forEach((g, i)=>{
        const oo = lerp(0.05, 0.10, pressure) * (0.8 + (i%3)*0.12);
        g.node.style.opacity = String(oo);
        const gx = px * lerp(6, 18, pressure) * (0.5 + i*0.05);
        const gy = py * lerp(5, 16, pressure) * (0.5 + i*0.04);
        g.node.setAttribute("transform", `translate(${gx}px, ${gy}px)`);
      });

      // Dashes: animate dash phase (subtle forensic scan)
      state.dashers.forEach((n, i)=>{
        if(state.reduced) return;
        const phase = (s * 320) + (i * 40);
        n.setAttribute("stroke-dashoffset", String(-phase));
      });

      // Ticks: slight intensity shift as if instrument calibrates
      state.ticks.forEach((t, i)=>{
        const o = t.axis === "top"
          ? lerp(0.18, 0.28, calm)
          : lerp(0.14, 0.24, pressure);
        t.node.setAttribute("stroke", `rgba(255,255,255,${o})`);
      });

      requestAnimationFrame(update);
    }

    function computeScroll01(){
      const doc = document.documentElement;
      const max = Math.max(1, doc.scrollHeight - doc.clientHeight);
      state.scroll01 = clamp(doc.scrollTop / max, 0, 1);
    }

    // Pointer drives subtle drift (optional)
    function onPointer(e){
      const w = window.innerWidth || 1;
      const h = window.innerHeight || 1;
      state.pointerX = clamp(e.clientX / w, 0, 1);
      state.pointerY = clamp(e.clientY / h, 0, 1);
    }

    // Init
    build();
    computeScroll01();
    window.addEventListener("scroll", computeScroll01, { passive:true });
    window.addEventListener("pointermove", onPointer, { passive:true });

    // Kick loop
    requestAnimationFrame(update);
  </script>
</body>
</html>
